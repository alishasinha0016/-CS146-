In this program, the concept of BFS and HashMap is used to find the combination of denominations with the least number of coins.
In the program, we first check the validity of the input. If any one of the given constraints is not met, we throw an Exception with the message of invalid input. Otherwise, we move forward. We also check if the amount is equal to 0. In case it is, we return 0 as no combination of denominations is required. 

In the method coinChange(), we declare and initialize queue and HashMap to perform BFS to track the minimum number of coins needed for each amount respectively. We start a while loop that continues until the queue is empty. Inside the loop, we dequeue an amount from the queue in each iteration. Now, for each coin denomination in the coins array, we calculate the next amount by adding the current amount to the coin value. In case the next amount equals the target amount, we return the minimum number of coins needed to reach the current amount + 1, since we are adding one more coin. Otherwise, if the next amount is less than the target amount and is not in the coinMap, we add it to the queue and update the coinMap with the minimum number of coins needed to reach the given amount. 

Now, if nothing was returned and the queue is empty, the while look stops and we return -1, meaning no combination was possible that could amount to the passed amount argument. 
